/** @file DataDecoder.java
 * @brief The class that decodes the received payload and extracts the data.
 * @author Hussein Khaleel, Mauricio Caceres
 */

package eu.ebbits.pwal.impl.driver.wsn.client;

import java.io.IOException;
import java.net.InetAddress;
import java.util.Dictionary;
import java.util.Hashtable;

import org.osgi.service.event.Event;

import eu.ebbits.pwal.impl.driver.wsn.WSNDriverImpl;


public class DataDecoder {
	
	private WSNDriverImpl driver;
	
	public DataDecoder(WSNDriverImpl driver) {
		this.driver = driver;
	}

	/** @name decode
	 * @brief Method to decode the received payload by UDPReceive.
	 * @param address The source IP address of the received packet.
	 * @param port The source port of the received packet.
	 * @param payload_length The length of the received payload.
	 * @param payload_data The array containing the received payload.
	 */
	public void decode(InetAddress address, int port, int payload_length, byte[] payload_data) throws IOException {
		//short[] data = new short[payload_length];
		int type = 0;
		String type_hex = "";
		int seq_no = 0;
		int temperature = 0;
		int acc_x_axis = 0;
		int acc_y_axis = 0;
		int acc_z_axis = 0;
		int sampling_rate = 0;
		int command = 0;
		String command_hex = "";
		int ack_data = 0;
		
		System.out.println();
		System.out.println("Received from: " + address.getHostName() + 
				", from port: " + port + 
				", payload length: " + payload_length + " bytes");

		/*
		//print the raw received bytes of the payload
		System.out.print("Raw bytes of payload: ");
		for (int i=0;i<payload_length;i++) {
			System.out.print(payload_data[i] + "  ");
		}
		System.out.println();
		*/
		
		/*
		//convert the received byte payload to short payload
		for (int i=0;i<payload_length;i++) {
			data[i] = (short) payload_data[i];
		}
		*/

		//packet type identification
		type = FormatDecoder.Decode8U(payload_data, 0);
		type_hex = Integer.toHexString(type);
		if(type_hex.equalsIgnoreCase("d0")) {
			System.out.println("Received data packet, type "+ type_hex);
			seq_no = FormatDecoder.Decode16U(payload_data, 2, false);
			temperature = (int)FormatDecoder.Decode32(payload_data, 4);
			acc_x_axis = (int)FormatDecoder.Decode32(payload_data, 8);
			acc_y_axis = (int)FormatDecoder.Decode32(payload_data, 12);
			acc_z_axis = (int)FormatDecoder.Decode32(payload_data, 16);
			sampling_rate = FormatDecoder.Decode16U(payload_data, 20, false);
			System.out.println("seq_no "+seq_no+", temperature " + temperature
					+", acc_x_axis "+acc_x_axis+", acc_y_axis "+acc_y_axis+", acc_z_axis "+acc_z_axis
					+", sampling_rate "+sampling_rate);
			//get the raw bytes of the sensor node IP address
			byte[] nodeAddress = address.getAddress();
			
			//create the payload
			byte[] payload = new byte[payload_length + nodeAddress.length];
			//filling up the payloadData
			for(int i=0;i<payload_length;i++) {
				payload[i]=payload_data[i];
			}
			//filling up the nodeAddress, starting from index: payloadLength+1
			for(int i=0;i<(nodeAddress.length);i++) {
				payload[payload_length+i]=nodeAddress[i];
			}
			Dictionary<String, byte[]> properties = new Hashtable<String, byte[]>();
			properties.put("packet", payload);

			Event packetEvent = new Event("pwal/wsndriver/packet", properties);
			driver.getEventsDelegate().sendEvent(packetEvent);
		}
		/*
		else if(type_hex.equalsIgnoreCase("d1")) {
			System.out.println("Received buffered data packet, type "+ type_hex);
			seq_no = encode16(data[2], data[3]);
			temperature = encode32(data[4], data[5], data[6], data[7]);
			buf_len = encode32(data[8], data[9], data[10], data[11]);
			//System.out.println();
			//System.out.println("seq_no "+seq_no);
			//System.out.println("temperature "+temperature);
			//System.out.println("buf_len "+buf_len);
			array_idx = 12;//readings start from here
			for (int i=0;i<buf_len;i++) {
				accel_x_axis[i]=encode32(data[array_idx], data[array_idx+1], data[array_idx+2], data[array_idx+3]);
				array_idx = (short) (array_idx + 4);
				//System.out.println("accel_x_axis["+i+"] "+accel_x_axis[i]);
			}
			for (int i=0;i<buf_len;i++) {
				accel_y_axis[i]=encode32(data[array_idx], data[array_idx+1], data[array_idx+2], data[array_idx+3]);
				array_idx = (short) (array_idx + 4);
				//System.out.println("accel_y_axis["+i+"] "+accel_y_axis[i]);
			}
			for (int i=0;i<buf_len;i++) {
				accel_z_axis[i]=encode32(data[array_idx], data[array_idx+1], data[array_idx+2], data[array_idx+3]);
				array_idx = (short) (array_idx + 4);
				//System.out.println("accel_z_axis["+i+"] "+accel_z_axis[i]);
			}
			sampling_rate = encode16(data[array_idx], data[array_idx+1]);
			//System.out.println("sampling_rate "+sampling_rate);
			//System.out.println();
			//proxy.ReceivedBufferedDataPacket(address, seq_no, temperature, buf_len, accel_x_axis, accel_y_axis, accel_z_axis, sampling_rate);
		}
		*/
		else if(type_hex.equalsIgnoreCase("a0")) {
			System.out.println("Received ack packet, type "+ type_hex);
			//command = encode16(data[2], data[3]);
			//ack_data = encode16(data[4], data[5]);
			command = FormatDecoder.Decode16U(payload_data, 2, false);
			command_hex = Integer.toHexString(command);
			ack_data = FormatDecoder.Decode16U(payload_data, 4, false);
			//get the raw bytes of the sensor node IP address
			byte[] nodeAddress = address.getAddress();
			
			//create the payload
			byte[] payload = new byte[payload_length + nodeAddress.length];
			//filling up the payloadData
			for(int i=0;i<payload_length;i++) {
				payload[i]=payload_data[i];
			}
			//filling up the nodeAddress, starting from index: payloadLength+1
			for(int i=0;i<(nodeAddress.length);i++) {
				payload[payload_length+i]=nodeAddress[i];
			}
			Dictionary<String, byte[]> properties = new Hashtable<String, byte[]>();
			properties.put("packet", payload);

			Event packetEvent = new Event("pwal/wsndriver/packet", properties);
			driver.getEventsDelegate().sendEvent(packetEvent);
		}
		else {
			System.out.println("Unknown packet received");
		}
	}

	/** @name encode16
	 * @brief Method to create a 16-bit integer from 2 received bytes.
	 * @param b1 The first byte.
	 * @param b2 The second byte.
	 * @return The created 16-bit integer.
	 */
	/*
	private static short encode16(short b1, short b2){
		short ret = 0;
		if(b2>=0){ //positive number
			if(b1<0) b1=(short) (b1+256);
			ret = (short) (b1 + b2*256);
		}
		else { //negative number
			if(b1>=0) b1=(short) (b1-256);
			ret = (short) (b1 + (b2+1)*256);
		}
		return ret;
	}
	*/

	/** @name encode32
	 * @brief Method to create a 32-bit integer from 4 received bytes.
	 * @param b1 The first byte.
	 * @param b2 The second byte.
	 * @param b3 The third byte.
	 * @param b4 The fourth byte.
	 * @return The created 32-bit integer.
	 */
	/*
	private static int encode32(short b1, short b2, short b3, short b4){
		int ret = 0;
		if(b4>=0){ //positive number
			if(b1<0) b1=(short) (b1+256);
			if(b2<0) b2=(short) (b2+256);
			if(b3<0) b3=(short) (b3+256);
			ret = (int) (b1 + b2*256 + b3*256*256 + b4*256*256*256);
		}
		else { //negative number
			if(b1>=0) b1=(short) (b1-256);
			if(b2>=0) b2=(short) (b2-256);
			if(b3>=0) b3=(short) (b3-256);
			ret = (int) (b1 + (b2+1)*256 + (b3+1)*256*256 + (b3+1)*256*256*256);
		}
		return ret;
	}
	*/
}