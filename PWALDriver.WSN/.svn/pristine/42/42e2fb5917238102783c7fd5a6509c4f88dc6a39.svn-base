package eu.ebbits.pwal.impl.driver.wsn.client;

import java.net.InetAddress;
import java.net.UnknownHostException;

import org.apache.log4j.Logger;

public class ProxyDecoder {

    private static final short TYPE_CONTROL_PAYLOAD = 192; //0xc0
    private static final short COMMAND_SET_RATE = 193; //0xc1
    private static final short COMMAND_STOP = 194; //0xc2
    //private static short COMMAND_GET_RATE = 195; //0xc3
    private static final short COMMAND_START = 196; //0xc4
    private CommandSender commandSender;
    private Logger log = Logger.getLogger(this.getClass().getName());
    
    
    public void decode(byte[] payloadData) {
        //short[] data = new short[payload_length];
        int type = 0;
        short seqNo = 0;
        short command = 0;
        short data1 = 0;
        short data2 = 0;
        short data3 = 0;
        InetAddress nodeAddress = null;
        byte[] nodeAddressByte = new byte[16];
        
        log.info("Received from proxy");

        /*
        //convert the payload bytes to short
        for (int i=0;i<payload_length;i++) {
            data[i] = (short) payload_data[i];
        }
         */

        //packet type identification
        type = FormatDecoder.decode16U(payloadData, 0, false);
        if(type==TYPE_CONTROL_PAYLOAD){
            log.info("Received TYPE_CONTROL_PAYLOAD");
            /*
            seq_no  = encode16(data[2], data[3]);
            command = encode16(data[4], data[5]);
            data_1  = encode16(data[6], data[7]);
            data_2  = encode16(data[8], data[9]);
            data_3  = encode16(data[10], data[11]);
             */
            seqNo  = (short)FormatDecoder.decode16U(payloadData, 2, false);
            command = (short)FormatDecoder.decode16U(payloadData, 4, false);
            data1  = (short)FormatDecoder.decode16U(payloadData, 6, false);
            data2  = (short)FormatDecoder.decode16U(payloadData, 8, false);
            data3  = (short)FormatDecoder.decode16U(payloadData, 10, false);
            //getting none_addr
            int ii = 12; //index to nodeAddress
            System.arraycopy(payloadData,0,nodeAddressByte,ii,nodeAddressByte.length);
            try {
                nodeAddress = InetAddress.getByAddress(nodeAddressByte); //got the sensor node IP address
            } catch (UnknownHostException e) {
                log.error(e.getStackTrace());
            }
            if(command==COMMAND_SET_RATE){
                log.info("Received COMMAND_SET_RATE to "+data1+", to node "+nodeAddress.getHostAddress());
                commandSender = new CommandSender();
                commandSender.sendControlCommand(nodeAddress, seqNo, COMMAND_SET_RATE, data1, data2, data3);
            }
            else if(command==COMMAND_START){
                log.info("Received COMMAND_START, to node "+nodeAddress.getHostAddress());
                commandSender = new CommandSender();
                commandSender.sendControlCommand(nodeAddress, seqNo, COMMAND_START, data1, data2, data3);
            }
            else if(command==COMMAND_STOP){
                log.info("Received COMMAND_STOP, to node "+nodeAddress.getHostAddress());
                commandSender = new CommandSender();
                commandSender.sendControlCommand(nodeAddress, seqNo, COMMAND_STOP, data1, data2, data3);
            }
        }
        else {
            log.warn("Unknown packet type");
        }
    }

    //Hussein: methods to create a variable from raw bytes

    /** @name encode16
     * @brief Method to create a 16-bit integer from 2 received bytes.
     * @param b1 The first byte.
     * @param b2 The second byte.
     * @return The created 16-bit integer.
     */
    /*
    private static short encode16(short b1, short b2){
        short ret = 0;
        if(b2>=0){ //positive number
            if(b1<0) b1=(short) (b1+256);
            ret = (short) (b1 + b2*256);
        }
        else { //negative number
            if(b1>=0) b1=(short) (b1-256);
            ret = (short) (b1 + (b2+1)*256);
        }
        return ret;
    }
     */

    /** @name encode32
     * @brief Method to create a 32-bit integer from 4 received bytes.
     * @param b1 The first byte.
     * @param b2 The second byte.
     * @param b3 The third byte.
     * @param b4 The fourth byte.
     * @return The created 32-bit integer.
     */
    /*
    private static int encode32(short b1, short b2, short b3, short b4){
        int ret = 0;
        if(b4>=0){ //positive number
            if(b1<0) b1=(short) (b1+256);
            if(b2<0) b2=(short) (b2+256);
            if(b3<0) b3=(short) (b3+256);
            ret = (int) (b1 + b2*256 + b3*256*256 + b4*256*256*256);
        }
        else { //negative number
            if(b1>=0) b1=(short) (b1-256);
            if(b2>=0) b2=(short) (b2-256);
            if(b3>=0) b3=(short) (b3-256);
            ret = (int) (b1 + (b2+1)*256 + (b3+1)*256*256 + (b3+1)*256*256*256);
        }
        return ret;
    }
     */
}
