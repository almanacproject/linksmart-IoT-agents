package eu.ebbits.pwal.impl.driver.opcxmlda.stub;

public class LimitBits extends ADBBeanImplementation {

	public static final javax.xml.namespace.QName MY_QNAME = new javax.xml.namespace.QName(
			OPC_NAMESPACE,
			"limitBits",
			OPC_PREFIX);

	
	protected String getClassName() {
		return this.getClass().getSimpleName();
	}
	

	/**
	 * field for LimitBits
	 */


	protected String localLimitBits ;

	private static java.util.HashMap _table_ = new java.util.HashMap();

	// Constructor

	protected LimitBits(String value, boolean isRegisterValue) {
		localLimitBits = value;
		if (isRegisterValue) {

			_table_.put(localLimitBits, this);

		}

	}

	public static final String _none =
			org.apache.axis2.databinding.utils.ConverterUtil.convertToString("none");

	public static final String _low =
			org.apache.axis2.databinding.utils.ConverterUtil.convertToString("low");

	public static final String _high =
			org.apache.axis2.databinding.utils.ConverterUtil.convertToString("high");

	public static final String _constant =
			org.apache.axis2.databinding.utils.ConverterUtil.convertToString("constant");

	public static final LimitBits none =
			new LimitBits(_none,true);

	public static final LimitBits low =
			new LimitBits(_low,true);

	public static final LimitBits high =
			new LimitBits(_high,true);

	public static final LimitBits constant =
			new LimitBits(_constant,true);


	public String getValue() { 
		return localLimitBits;
	}

	public boolean equals(java.lang.Object obj) {
		return (obj == this);
	}
	
	public int hashCode() { 
		return toString().hashCode();
	}
	
	public String toString() {
		return localLimitBits.toString();
	}

	protected void writeAttributes(String prefix,
			 String namespace, 
			 org.apache.axiom.om.OMFactory factory, 
			 org.apache.axis2.databinding.utils.writer.MTOMAwareXMLStreamWriter xmlWriter) 
					 throws javax.xml.stream.XMLStreamException, org.apache.axis2.databinding.ADBException {

		 if (localLimitBits==null) {
			 throw new org.apache.axis2.databinding.ADBException("Value cannot be null !!");
		 }else{
			 xmlWriter.writeCharacters(localLimitBits);
		 }
		 xmlWriter.writeEndElement();
	 }
	 
	 protected void setPrefixAndNamespace(String prefix, 
			 							String namespace, 
			 							org.apache.axis2.databinding.utils.writer.MTOMAwareXMLStreamWriter xmlWriter) {

	 }
	 


	 /**
	  * databinding method to get an XML representation of this object
	  *
	  */
	 public javax.xml.stream.XMLStreamReader getPullParser(javax.xml.namespace.QName qName)
			 throws org.apache.axis2.databinding.ADBException{

		 //We can safely assume an element has only one type associated with it
		 return new org.apache.axis2.databinding.utils.reader.ADBXMLStreamReaderImpl(MY_QNAME,
				 new java.lang.Object[]{
				 org.apache.axis2.databinding.utils.reader.ADBXMLStreamReader.ELEMENT_TEXT,
				 org.apache.axis2.databinding.utils.ConverterUtil.convertToString(localLimitBits)
		 },
		 null);
	 }



	 /**
	  *  Factory class that keeps the parse method
	  */
	 public static class Factory {

		 public static LimitBits fromValue(String value) {
			 LimitBits enumeration = (LimitBits) _table_.get(value);
			 if (enumeration==null) {
				 throw new java.lang.IllegalArgumentException();
			 }
			 return enumeration;
		 }
		 
		 public static LimitBits fromString(String value,String namespaceURI)  {
			 try {
				 return fromValue(value);
			 } catch (java.lang.Exception e) {
				 throw new java.lang.IllegalArgumentException();
			 }
		 }

		 public static LimitBits fromString(javax.xml.stream.XMLStreamReader xmlStreamReader,
				 String content) {
			 if (content.indexOf(':') > -1) {
				 String prefix = content.substring(0,content.indexOf(':'));
				 String namespaceUri = xmlStreamReader.getNamespaceContext().getNamespaceURI(prefix);
				 return LimitBits.Factory.fromString(content,namespaceUri);
			 } else {
				 return LimitBits.Factory.fromString(content,"");
			 }
		 }


		 /**
		  * static method to create the object
		  * Precondition:  If this object is an element, the current or next start element starts this object and any intervening reader events are ignorable
		  *			 If this object is not an element, it is a complex type and the reader is at the event just after the outer start element
		  * Postcondition: If this object is an element, the reader is positioned at its end element
		  *			 If this object is a complex type, the reader is positioned at the end element of its outer element
		  */
		 public static LimitBits parse(javax.xml.stream.XMLStreamReader reader) throws java.lang.Exception{
			 LimitBits object = null;
			 try {
				 GenericFactory.goToNextStartElement(reader);
				 while(!reader.isEndElement()) {
					 if (reader.isStartElement()  || reader.hasText()) {
						 String content = reader.getElementText();
						 object = LimitBits.Factory.fromString(content,GenericFactory.getNamespaceURI(reader,content));
					 } else {
						 reader.next();
					 }  
				 }  // end of while loop
			 } catch (javax.xml.stream.XMLStreamException e) {
				 throw new java.lang.Exception(e);
			 }
			 return object;
		 }
	 }//end of factory class
}