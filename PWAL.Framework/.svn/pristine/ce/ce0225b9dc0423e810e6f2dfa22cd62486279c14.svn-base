package eu.ebbits.pwal.api.model;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * Class to represent generic Events types (as well as Event instances) inside 
 * the <code>PWAL</code>. For example, this model could represent a 
 * <code>TemperatureValueReceived</code> Event or an Alarm event.
 * <p>
 * <code>PWALEvent</code>s represent physical world events which can be 
 * generated by the <code>PWALDriver</code> and propagated to the Device 
 * Manager. An event can be associated with an arbitrary number of 
 * <code>PWALVariable</code>s. 
 * <p>
 * PWALEvents can be extended to support driver-specific event types.
 * <p>
 * Copyright (c) 2010-2012 the ebbits project. All Rights Reserved.
 *
 * @author	 ISMB
 * @version	%I%, %G%
 * @see	    eu.ebbits.pwal.api.model.PWALService
 * @see			eu.ebbits.pwal.api.model.PWALVariable
 * @since	  PWAL 0.1.0
 */
public class PWALEvent  extends PWALObject {

	// TODO either name or method are nulls... Probably I should split PWALEvent
	// into PWALEvent and PWalEventType ... 
	
	/** Internal method. */	// TODO Should we change method into PWALMethod?
	private Method method;
	
	/** Collection of eventful variables. */
	private Map<String, PWALVariable> variablesmap;
	
	/**
	 * Constructor based on the Inner method object. 
	 * In some use-cases (especially if Reflective methods are employed) 
	 * it might be easier to model an event as a simple function call.
	 * If so, the PWAL event is created using this constructor.
	 *
	 * @param m	-	the internal <code>Method</code>
	*
	* @since		PWAL 0.1.0
	 */
	public PWALEvent(final Method m) {
		super(m.getName());
		this.method = m;
		this.init();
	}

	/**
	 * Variable-based on the Inner method object. 
	 * In some use-cases, simpler means of instantiating events are better 
	 * suited (e.g. when the number of associated variables is not known a 
	 * priori). 
	 * If so, the PWAL event is created using this constructor.
	 *
	 * @param name - the event name <code>String</code>
	*
	* @since		PWAL 0.1.0
	 */
	public PWALEvent(final String name) {
		super(name);
		this.init();
	}

	/**
	 * Initializes the <code>PWALEvent</code>.
	 *
	* @since		PWAL 0.1.0
	 */
	private void init() {
		this.variablesmap = new HashMap<String, PWALVariable>();
		
	}

	/**
	 * Retrieves the internal method.
	 *
	 * @return		the internal <code>Method</code>
	* @since		PWAL 0.1.0
	 */
	public final Method getMethod() {
		return this.method;
	}

	/**
	 * Modifier to extend an existing event with an additional event type.
	 *
	 * @param var -	the <code>PWALVariable</code> to add
	*
	* @since		PWAL 0.1.0
	 */
	public final void addVariable(final PWALVariable var) {
		this.variablesmap.put(var.getName(), var);
	}
	
	/**
	 * Retrieve the eventful variable.
	 *
	 * @param nam -	the variable name <code>String</code> to get
	 *
	 * @return		the <code>PWALVariable</code> with the given name if exist,
	 * 				<code>null</code> otherwise
	*
	* @since		PWAL 0.1.0
	 */
	public final PWALVariable getVariable(final String nam) {
		return this.variablesmap.get(nam);
	}
	
	/**
	 * Retrieve the number of eventful variables.
	 *
	 * @return		the size of the eventful variables collection
	*
	* @since		PWAL 0.1.0
	 */
	public final int getVariablesSize() {
		return this.variablesmap.size();
	}

	/**
	 * Generates a string representation of the object.
	 *
	 * @return		the <code>String</code> representation
	 *
	* @since		PWAL 0.1.0
	 */
	public String toString() {
		String ret = this.getName() + " [";
		int i = 0;
		int size = this.variablesmap.size();
		for (PWALVariable v : this.variablesmap.values()) {
			ret += v.toString();
			i++;
			if (i != size) {
				ret += ",";
			}
		}
		ret += "]";
		return ret;
	}

}
